# 正则匹配原理

*2017-06-01*

## 正则引擎

正则匹配需要用到正则引擎（抽象的自动机），分为NFA和DFA。ECMAScript的正则引擎同perl，采用的是NFA引擎。这个这个引擎最重要的部分是回溯。DFA和NFA反映了将正则表达式在应用算法上的根本差异。NFA称为“表达式主导(regex-directed)”引擎，DFA称为“文本主导(text-directed)”引擎。 

## 匹配原理

1. 引擎的构造

   正则引擎中的零件分为：

   __文字字符__：对于非元字符的文字字符，尝试匹配时需要考虑该字符与当前匹配的字符是否相同

   __字符组__：".","\W","\d".无论字符组的长度是多少，它只能匹配一个字符

   __捕获型括号__：用于捕获文本的括号（而不是用于分组的括号）不会影响匹配过程

   __锚点__：可以分简单锚点(^,$,\b)和复杂锚点（顺序环视，逆序环视）

2. 最基本的原理

   匹配先从要查找的字符串的起始位置尝试匹配。尝试匹配的意思是在当前位置测试整个表达式能匹配的每样文本。如果当前位置测试了所有可能（因为可能会有多选项或量词）之后不能找到结果，就需要从字符串的第二个字符之前的位置开始尝试。在找到匹配结果以前必须在所有的位置重复此过程。只有在尝试过所有位置都不能找到匹配结果的情况下才宣告匹配失败。

   标准量词（?,+,*,{min,max}）都是匹配优先的，这些匹配__总是希望最长的匹配__。举个例子，用/\w/匹配”regexes“,	匹配结果是regexes,这是最长的匹配。这里有一个__过度优先匹配的问题__：我们用/^.\*[0-9]/匹配一行最后一位是数字的字符。^匹配开始位置，然后(.\*)尽可能多的匹配字符，会匹配正行文本，然后[0-9]是必须匹配的，再尝试匹配行末时会失败，这时会通知(.\*):"hi,你占的字符太多啦，交出来一些字符吧，这样我可能能匹配"。这时匹配优先组件会释放一些字符，释放总是一个一个释放，可能释放多次，当然释放是有底线的，就是释放字符必须保证匹配优先组的自己的下限，比如加号需要保证自己保留一个字符。这里又会出现一个交还多少的问题：/^.\*[0-9]+/匹配”reg2017.“这时^.\*会先匹配字符串，然后[0-9]+需要至少匹配一个数字，这时会让前一个表达式交出一些字符，交出”.“后不能匹配，需要继续交出，交出7能够匹配，此时已经完成了匹配，前一个表达式不会再继续交出1，因为有一个原则叫做：__先来先服务原则__，先满足前面的匹配优先字符。

3. 回溯

   NFA最重要的一个特性是回溯。按上边的基本原理NFA按从左到右的顺序依次处理各个子表达式或元素，当出现多种匹配可能时，选择一种可能进行下去，同时记录其他可能供备选，当一种可能尝试失败后回退到分歧点选择另一种备选方案，如果一个可能匹配成功宣告匹配成功，如果所有备选方案都走完也没有匹配成功宣告匹配失败。一个简单的例子/may(day|time)/匹配”…meet,smaydate maytime“,表达式主导，先从m开始匹配，知道匹配到第4个字符时发现匹配成功，之后匹配a，发现不能匹配，然后回溯回m匹配，匹配e失败，匹配t失败，知道匹配到may，发现有两种可能，假设引擎选择day走下去，保留time，匹配失败，然后回退到time的备选发现匹配成功了。备选分支的选择顺序要遵从LIFO(last in first out)

   匹配优先和忽略优先，也称为贪婪模式和非贪婪模式。匹配优先量词是上文提到的（?,+,\*,{min,max}）。匹配优先量词在匹配时首先会尝试匹配，__如果失败后回溯才会选择忽略__。比如/ab\*/匹配abb,当匹配成功a后，引擎有两个选择，一个是匹配后边的b,一个是忽略后边的b,由于匹配优先，所以引擎会尝试匹配，发现匹配得到了ab，之后在尝试同样的问题，得到了abb，之后再匹配发现没有字符了，返回匹配成功。忽略优先量词是在匹配优先量词后加上?(??,+?,\*?,{min,max}?),相反的忽略优先量词在匹配时会首先尝试忽略，__如果失败后回溯才尝试匹配。比如用/ab*?/匹配abb,会得到a而不是abb。

   > note: js的正则匹配不支持回溯固化分组。

4. 环视

   环视不匹配任何字符，只匹配文本中的特定位置，这点和单词分界符（\b,^,$）相似

   (?=)称为肯定顺序环视，如/x(?=y)/匹配x仅当后面紧跟y时，如果符合匹配，只有x会被记住，y不会被记住

   (?!)称为否定顺序环视，如/x(?!y)/匹配x仅当后面不紧跟y时，如果符合匹配，只有x会被记住，y不会被记住

   在环视内部的备用状态一旦退出环视范围立即清除，外部回溯不能回溯到环视内部的备用状态，使用/ab\w+c/和/ab(?=\w+)c/匹配字符串abbbbc，第一个表达式会成功，第二个表达式会失败

5. 捕获组及反向引用

   捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。

   捕获组有两种形式，一种是普通捕获组，另一种是命名捕获组，通常所说的捕获组指的是普通捕获组

   普通捕获组：(Expression)

   命名捕获组：(?<name>Expression)

   普通捕获组编号规则：编号为0的捕获组指的是正则表达式整体。除此之外编号按照”(“出现的顺序，从左到右，从1开始编号

   ![](http://p.blog.csdn.net/images/p_blog_csdn_net/lxcnn/EntryImages/20090810/normal.JPG)

   正则表达式中，对前面捕获组捕获的内容进行引用，成为反向引用，普通捕获组的反向引用语法是/number,如`/\b([a-z]+) \1\b/`，可以匹配两个相同的词之间包含空格的字符串。如果从正则外部调用可以javascript可以使用$number的形式调用

6. 提高正则性能

   * 或的顺序。匹配ab13_b:bbbb:c34d， /(:|\w)\*/用50步，/(\w|:)\*/用38步
   * 多选代价高。匹配The name “McDonald’s” is said “makudonarudo” in Japanese这段字符串，/u|v|w|x|y|z/要用206步，[uvwxyz]只需要36步，这是因为字符组特点就在于内部匹配不是我们所想的一个一个去匹配，在生成字符组的时候会消耗一点点性能，但是在匹配的时候是一次性就可以判定是否能够匹配，而或分支会在每次匹配时产生多个备选进行回溯，这一点上效率要差很多
   * 使用非捕获型括号，这样会减少回溯使用的状态的数量减少内存消耗。
   * 提取必要的元素。用/th(?:is|at)/代替/(?:this|that)/，这样能暴露出必须的th。

## 常用正则表达式

| 匹配含义             | 表达式                                      |
| ---------------- | ---------------------------------------- |
| 中文               | [\u4e00-\u9fa5]                          |
| 英文数字最小6个字符，且字母开头 | ^(?=[A-Za-z])[A-Za-z0-9]{6,}$            |
| 邮箱               | ^[a-z0-9]+([._\\-]*[a-z0-9])*@([a-z0-9]+[a-z0-9]*[a-z0-9]+\.){1,63}[a-z0-9]+$ |
| 移动手机号            | /^1(3[456789]{1}\|47\|5[012789]{1}\|78\|8[23478]{1})\d{8}$/ |
| 联通手机号            | /^1(3[012]{1}\|45\|5[56]{1}\|76\|8[56]{1})\d{8}$/ |
| 电信手机号            | /^1(33\|53\|77\|8[019]{1})\d{8}$/        |
| 虚拟运营商手机号         | /^170\d{8}$/                             |
| 身份证              | (^\d{15}\$)\|(^\d{18}\$)\|(^\d{17}(\d\|X\|x)$) |
| 大整数逗号千分          | \d+?(?=(?:\d{3})+$)                      |
| html 标记          | <(\S*?)[^>]*>.*?</\1>\|<.*? />           |
| QQ号              | \[1-9][0-9]{4,}                          |
| IP地址             | ((25[0-5]\|2[0-4]\d\|[01]?\d\d?)\.){3}(25[0-5]\|2[0-4]\d\|[01]?\d\d?) |
| 完整域名             | \[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.\[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.? |

