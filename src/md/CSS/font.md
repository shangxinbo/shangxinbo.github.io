# WEB字体

先了解字体的两个重要概念
- 衬线字体：笔画有额外的装饰，笔画的粗细有所不同。比如宋体
- 无衬线体：笔画的粗细差不多。比如黑体

## 网络安全字体
兼容所有系统的字体，可以保证你肆无忌惮的使用就是网络安全字体。
比如Helvetica,Arial，两者显示差不多，Arial最广泛使用，Helvetical有更好的形状。

## font-family
定义一个或几个字体名供浏览器选择，字体名称有些是多个单词组成需要用双引号包裹，以逗号隔开。

它的属性值可以理解而成字体栈的结构，浏览器会从前往后一个一个的查找字体，所以一般把通用的广泛支持的字体放到后边做备案，以防出现找不到字体，页面上的文字无法显示的情况。


属性中的字体名称可以是有明确指定含义的字体族，比如Arial，也可以是具有动态含义的字体族，比如system ui

其中的动态字体族是由CSS字体模型规范中给与定义的，

css-fonts-3中定义了5个动态字体族，[REC-css-font-3](https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/#generic-font-families)

  - serif 衬线字体族
  - sans-serif 非衬线字体族
  - monospace 等宽字体，即字体中每个字宽度相同
  - cursive 草书字体
  - fantasy 主要是那些具有特殊艺术效果的字体

css-fonts-4 中新增了几个关键词[css-fonts-4](https://www.w3.org/TR/css-fonts-4/#generic-font-families)

  - system-ui 系统默认字体
  - emoji 用于兼容 emoji 表情符号字符
  - math 适用于数学表达式
  - fangsong 此字体系列用于中文的（仿宋）字体。

熟悉了字体栈的先后关系和一些字体的通用性我们来看一个当前定义一个Web字体代码
```
font-family: 'PingFang SC','Microsoft Yahei',system-ui, -apple-system, Roboto, Helvetica,Arial,sans-serif,emoji;
```
其中以system-ui为分界限，前边的是激进的字体簇，后边的是保守的兼容的字体族，-apple-system是在老版本macos和ios系统上的system-ui的兼容版本。
PingFang SC尽在比较新的苹果系统平台上支持，YaHei只在Windows7以上平台支持，Roboto是Android系统默认字体。微软雅黑是更合适中文排版；以英文为主，Segoe UI 更加适合。


## 自定义字体
理论上我们应该推荐使用系统字体，因为系统字体不会消耗太多网络资源，但是如果希望字体更艺术化或者有更好的设计元素的字体，那我们可以自定义字体，掌握几个原则：
- 英文字体基本上可以使用自定义字体，
- 中文字体可小范围使用，不可大范围使用，注入有几个文字想要使用艺术特效可以指定几个字体的字体簇
- 尽量用压缩比例更强的字体文件格式

字体格式，其他字体格式的平台兼容性不可保证，不做讨论
- ttf 最泛用
- woff 2012年相对泛用，同样的字体体积是ttf的60%-70%大小
- woff2 2018年最新的字体标准，需要注意兼容性，同样字体是ttf的40%-50%大小

目前的设备环境woff格式完全可以兼容所有平台可以看支持程度
https://caniuse.com/?search=WOFF

### @font-face
```
@font-face {
  font-family: 'CustomFont';
  src: url('customfont.woff2'),
       url('customfont.woff'),
       url('customfont.ttf');
  font-weight: normal;
  font-style: normal;
}
```
因为字体可能有多种style和weight，可以指定多个font-face来定义


## 字体子集
正如上面所说，中文字符集很大，不管是什么格式，全量unicode字符会有几M甚至几十M的大小，这对WEB是非常重的资源，强行使用中文字体文件反而会出现严重的页面重绘现象，严重影响用户体验。

字体子集是解决这个问题很有效的方案，通常一个中文字体会包含20000~30000个中文字符，那么我们的应用场景中可能未必会用到这么多的字符，于是我们可以做一个页面上用到的字符的字体簇文件，这就是字体的子集。
比如我们中文常用字3500个，我们可以把这3500个做成一个新的字体文件，相较于30000个的字体文件要小了将近1倍的体积。

这也是当年字蛛出现的原因

字蛛会分析页面上用到的字符，来动态生成字体子集，然而有2个弊端
- 字蛛只能分析静态文件中的字符，通过接口或者用户输入拿来的文字不能包含在子集中，这极有可能出现字体不存在的情况，这是从原理上无法使用字蛛的原因。
- 字体文件会根据项目中文字的增多而不断变化，那么就产生了字体文件版本的概念，字体文件不同版本出现就会让客户端频繁的下载字体文件，而失去了浏览器缓存的优势。

以上从根本上说明字蛛不可能在大项目中或者稳定性强的C端产品中使用。

Google Fonts 在2018年有过一些尝试，他们把日文和韩文字体通过统计数据分成常用，次常用，剩余全量字符。
他们把常用字放到一个切片中，次常用放到一个切片中，然后把剩余字符分成100个大小相等的切片，然后利用HTTP/2的同时传输有效的降低了下载字体文件的字节数

然而这个尝试是在有足够统计数据的情况下做的通用性方案，针对我们子集的项目，这个方案也有风险。

所以字符子集的方案，为了不影响用户，现在还是尽量的实现大子集，或者尽量的把子集的范围放大，以防页面文字出现空缺的情况，可能未来会有新的方式实现

## 参考

https://fonts.google.com/