# 浏览器渲染引擎

本文标题是浏览器工作原理，但实质上是在讲解__浏览器渲染的流程__，主要讲浏览器呈现引擎的工作流程。而呈现引擎默认可显示HTML和XML文档与图片，还可以显示其他内容比如PDF等，我们这里也只讲主要用途：显示使用CSS格式化的HTML内容和图片

本分主要探讨Safari和Chrome的渲染引擎 Webkit和Blink，其实Blink也是在Webkit的一个分支上做的

Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。

### HTML解析(HTML parse)形成DOM树

解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。

一般的解析器分为两类自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。

然而很遗憾，所有的常规解析器都不适用于 HTML。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。所以在HTML4时，需要借助SGML的DTD格式来解析，在HTML5规范制定时，由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析HTML。HTML5规范详细的描述了解析算法。这是为什么说HTML5不再是基于SGML的依据。

文档解析完成后输出DOM Tree .Dom与HTML之间几乎是一一对应关系。


> 浏览器纠错
>
> 您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。

### CSS 解析(CSS parse)

和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。在CSS规范中已经定义好了词法和语法，所以CSS解析简单。

### JS和CSS的顺序

网络模型是同步的。网页作者希望解析器遇到 `<script>` 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。这个过程称为JS阻塞（你可以在script标签上定义defer来异步这个过程）

JS的预解析

WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。所以其实JS在这两种浏览器中是并行加载的。

可想而知，CSS加载并不会阻塞DOM的解析，那么CSS加载实质上并不会阻塞DOM解析和JS加载但是由于js加载是有阻断作用的，所以会出现一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。所以Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

所以可以理解为CSS加载并不会阻断JS加载但有可能阻断JS执行

### 渲染树

当DOM Tree 链接 CSS Rules Tree 后形成渲染树(Render Tree)。渲染树和DOM树并非一一对应，非可视化的DOM元素不会插入到呈现树中，所以渲染Tree应该是从body元素开始的，同样display:none的元素也不会出现在Render Tree 中(但visibility:hidden的会显示)。有一些DOM元素对应多个可视化对象(Render object)，它们往往是具有复杂结构的元素，无法用单一的矩形来描述，例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。

这里渲染树里的可视化对象的可视属性是CSS计算属性的最终值，样式计算请查看CSS2.1的可视化格式模型详细。



### 布局(painting)

呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。分为全局布局和增量布局

### 绘制(display)

在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。分为全局绘制和增量绘制


[浏览器的工作方式](https://web.dev/articles/howbrowserswork?hl=zh-cn)